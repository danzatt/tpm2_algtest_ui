#!/usr/bin/python3

# Copyright (C) 2022 Daniel Zatovic
# parts Copyright (C) 2019 Simon Struk
# parts Copyright (C) 2022 Antonin Dufka

from collections import deque
from enum import Enum, auto

from threading import Thread, Lock
import subprocess
import fcntl
import os
import csv
import glob
import requests
import json
import datetime
import zipfile

from shutil import copyfile
from uuid import uuid4
from tempfile import mkdtemp

from yui import YUI
from yui import YEvent

VERSION = ' v.0.2'
IMAGE_TAG = 'tpm2-algtest-ui ' + VERSION
RESULT_PATH = "/mnt/algtest"
TCTI_SPEC = "device:/dev/tpm0"
DEPOSITORY_UCO = 4085
INFO_MESSAGE = \
"""<b>Experiment</b>: Analysis of Trusted Platform Modules
<b>Research institute</b>: CRoCS laboratory, Masaryk University and Red Hat
<b>Contact person</b>: Petr Svenda &lt;svenda@fi.muni.cz&gt;

<b>What to do:</b>
<ol>
    <li>Please read the information about the experiment below</li>
    <li>Run the test by clicking 'Start TPM test' button. The test runs for approximately 1-4 hours.</li>
    <li>Unplug USB disk, restart to your standard system, plug USB disk again</li>
    <li>Upload file(s) algtest_result_xxx.zip file from the USB disk at https://is.muni.cz/go/tpm</li>
</ol>

<b>Goal of the research:</b>
The goal of the research is to get a better understanding of the Trusted
Platform Modules ecosystem. Such information is vital for the designers and
developers using this technology, allowing then to answer questions like: What
fraction of devices has TPM chip? Which cryptographic algorithms are widely
supported? What is the overhead of computing a digital signature?

We do not collect any personal data. We collect only the TPM chip metadata,
performance measurements and temporary cryptographic keys generated by TPM chip
and product name of your device (e.g., Lenovo ThinkBook 15). We plan to release
the data collected later as an open research dataset.

<b>Data we collect:</b>
<ul>
    <li>Device vendor and type (e.g., Lenovo ThinkBook 15)</li>
    <li>TPM vendor, firmware version (e.g., Intel 401.1.0.0) and TPM
    version-related information</li>
    <li>TPM metadata (TPM_PT_xxx properties like TPM_PT_REVISION,
    TPM_PT_MANUFACTURER or TPM_PT_PCR_COUNT - see file
    Quicktest_properties-fixed.txt and Quicktest_properties-variable.txt for full
    list)</li>
    <li>Algorithms and commands supported by TPM (TPMA_ALGORITHM and TPMA_CC
    properties, see Quicktest_algorithms.txt and Quicktest_commands.txt for full
    list)</li>
    <li>Performance measurements for various cryptographic algorithms (see
    Perf_xxx.csv files)</li>
    <li>Freshly generated, transient keys for ECC and RSA (see Keygen_ECC_xxx.csv
    and Keygen_RSA_xxx.csv).</li>
</ul>

<b>Specifically, we do NOT collect:</b>
<ul>
    <li>Personal information about the user of the computer analyzed</li>
    <li>Endorsement key</li>
    <li>Attestation key(s)</li>
    <li>User-specific content of the non-volatile TPM memory (NVRAM)</li>
</ul>

<b>Data retention:</b>
<ul>
    <li>We plan to release the data collected as open research dataset to enable
    wider research cooperation.</li>
    <li>The data collected will be first analyzed by CRoCS research team for the
    purpose of analysis current TPM chip ecosystem. We plan to release the data
    collected together with the research findings.</li>
</ul>

<b>Thank you a lot for cooperation!</b>""".replace("\n", "<br>")

INFO_MESSAGE_PLAIN = \
"""Experiment: Analysis of Trusted Platform Modules
Research institute: CRoCS laboratory, Masaryk University and Red Hat
Contact person: Petr Svenda <svenda@fi.muni.cz>

What to do:
1. Please read the information about the experiment below
2. Run the test by
   clicking 'Start TPM test' button. The test runs for approximately 1-4 hours.
3. Unplug USB disk, restart to your standard system, plug USB disk again
4. Upload file(s) algtest_result_xxx.zip file from the USB disk at https://is.muni.cz/go/tpm

Goal of the research:
The goal of the research is to get a better understanding of the Trusted
Platform Modules ecosystem. Such information is vital for the designers and
developers using this technology, allowing then to answer questions like:
- What fraction of devices has TPM chip?
- Which cryptographic algorithms are widely supported?
- What is the overhead of computing a digital signature?

We do not collect any personal data. We collect only the TPM chip metadata,
performance measurements and temporary cryptographic keys generated by TPM chip
and product name of your device (e.g., Lenovo ThinkBook 15). We plan to release
the data collected later as an open research dataset.

Data we collect:
- Device vendor and type (e.g., Lenovo ThinkBook 15)
- TPM vendor, firmware version (e.g., Intel 401.1.0.0) and TPM version-related
  information
- TPM metadata (TPM_PT_xxx properties like TPM_PT_REVISION, TPM_PT_MANUFACTURER
  or TPM_PT_PCR_COUNT - see file Quicktest_properties-fixed.txt and
  Quicktest_properties-variable.txt for full list)
- Algorithms and commands supported by TPM (TPMA_ALGORITHM and TPMA_CC
  properties, see Quicktest_algorithms.txt and Quicktest_commands.txt for full
  list)
- Performance measurements for various cryptographic algorithms (see
  Perf_xxx.csv files)
- Freshly generated, transient keys for ECC and RSA (see Keygen_ECC_xxx.csv and
  Keygen_RSA_xxx.csv).

Specifically, we do NOT collect:
- Personal information about the user of the computer analyzed
- Endorsement key
- Attestation key(s)
- User-specific content of the non-volatile TPM memory (NVRAM)

Data retention:
- We plan to release the data collected as open research dataset to enable
  wider research cooperation.
- The data collected will be first analyzed by CRoCS research team for the
  purpose of analysis current TPM chip ecosystem. We plan to release the data
  collected together with the research findings.

Thank you a lot for cooperation!"""


class ISUploader:
    def __init__(self, user_agent, uco):
        self.user_agent = user_agent
        self.uco = uco
        self.headers = {
            'User-Agent': self.user_agent
        }

        self.params = (
            ('vybos_vzorek_last', ''),
            ('vybos_vzorek', self.uco),
            ('vybos_hledej', 'Vyhledat osobu')
        )

    def upload(self, filename, description="", mail_text=""):
        try:
            files = {
                'quco': (None, self.uco),
                'vlsozav': (None, 'najax'),
                'ajax-upload': (None, 'ajax'),
                'FILE_1': (filename, open(filename, 'rb')),
                'A_NAZEV_1': (None, filename),
                'A_POPIS_1': (None, description),
                'TEXT_MAILU': (None, mail_text),
            }

            response = requests.post('https://is.muni.cz/dok/depository_in', headers=self.headers, params=self.params, files=files)
            json_response = json.loads(response.content.decode("utf-8"))
            if json_response["uspech"] != 1:
                return False
        except:
            return False
        return True


class TestResultCollector:
    def __init__(self, outdir, email, ui_log, watchdog_tick=None):
        self.outdir = outdir
        self.detail_dir = os.path.join(self.outdir, 'detail')
        self.zip_path = None
        self.email = email
        self.ui_log = ui_log
        self.watchdog_tick = watchdog_tick

    def create_result_files(self):
        self.tick()
        manufacturer, vendor_str, fw = self.get_tpm_id()
        file_name = manufacturer + '_' + vendor_str + '_' + fw + '.csv'

        os.makedirs(os.path.join(self.outdir, 'results'), exist_ok=True)
        with open(os.path.join(self.outdir, 'results', file_name), 'w') as support_file:
            self.write_header(support_file)
            self.write_support_file(support_file)
        self.tick()

        os.makedirs(os.path.join(self.outdir, 'performance'), exist_ok=True)
        with open(os.path.join(self.outdir, 'performance', file_name), 'w') as perf_file:
            self.write_header(perf_file)
            self.write_perf_file(perf_file)
        self.tick()

        with open(os.path.join(self.outdir, 'ui_timestamp_log.log'), 'w') as ui_log_file:
            ui_log_file.write("\n".join(self.ui_log))
        self.tick()

    def write_header(self, file):
        self.tick()
        manufacturer, vendor_str, fw = self.get_tpm_id()
        self.tick()
        system_manufacturer, product_name, system_version, bios_version = self.get_system_id()
        if self.email is not None:
            file.write(f'Tested and provided by;{self.email}\n')
        file.write(f'Execution date/time;{datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")}\n')
        file.write(f'Manufacturer;{manufacturer}\n')
        file.write(f'Vendor string;{vendor_str}\n')
        file.write(f'Firmware version;{fw}\n')
        file.write(f'Image tag;{IMAGE_TAG}\n')
        file.write(f'TPM devices;{";".join(glob.glob("/dev/tpm*"))}\n')
        file.write(f'Device manufacturer;{system_manufacturer}\n')
        file.write(f'Device name;{product_name}\n')
        file.write(f'Device version;{system_version}\n')
        file.write(f'BIOS version;{bios_version}\n\n')

    def get_system_id(self):
        manufacturer = None
        product_name = None
        version = None
        bios_version = None

        system_info = os.path.join(self.detail_dir, 'dmidecode_system_info.txt')
        if os.path.isfile(system_info):
            with open(system_info, 'r') as dmidecode_file:
                output = dmidecode_file.read().replace("\t", "").split("\n")
                try:
                    manufacturer = output[1].split(":")[1][1:]
                except:
                    pass

                try:
                    product_name = output[2].split(":")[1][1:]
                except:
                    pass

                try:
                    version = output[3].split(":")[1][1:]
                except:
                    pass
        system_info = os.path.join(self.detail_dir, 'dmidecode_bios_version.txt')
        if os.path.isfile(system_info):
            with open(system_info, 'r') as dmidecode_bios_file:
                bios_version = dmidecode_bios_file.readline()[:-1]
        return manufacturer, product_name, version, bios_version

    def get_tpm_id(self):
        def get_val(line):
            return line[line.find('0x') + 2:-1]

        manufacturer = ''
        vendor_str = ''
        fw = ''
        qt_properties = os.path.join(self.detail_dir, 'Quicktest_properties-fixed.txt')
        if os.path.isfile(qt_properties):
            with open(qt_properties, 'r') as properties_file:
                read_vendor_str = False
                read_manufacturer_str = False
                read_fw1_str = False
                read_fw2_str = False
                fw1 = ''
                fw2 = ''
                for line in properties_file:
                    if read_vendor_str:
                        val = get_val(line)
                        if len(val) % 2 != 0:
                            val = "0" + val

                        vendor_str += bytearray.fromhex(val).decode()
                        read_vendor_str = False
                    elif read_manufacturer_str:
                        val = get_val(line)
                        if len(val) % 2 != 0:
                            val = "0" + val

                        manufacturer = bytearray.fromhex(val).decode()
                        read_manufacturer_str = False
                    elif line.startswith('TPM2_PT_MANUFACTURER'):
                        read_manufacturer_str = True
                    elif line.startswith('TPM2_PT_FIRMWARE_VERSION_1'):
                        read_fw1_str = True
                    elif read_fw1_str:
                        fw1 = line[line.find('0x') + 2:-1]
                        read_fw1_str = False
                    elif line.startswith('TPM2_PT_FIRMWARE_VERSION_2'):
                        read_fw2_str = True
                    elif read_fw2_str:
                        fw2 = line[line.find('0x') + 2:-1]
                        read_fw2_str = False
                    elif line.startswith('TPM2_PT_VENDOR_STRING_'):
                        read_vendor_str = True
                try:
                    fw1 = "0" * (8 - len(fw1)) + fw1
                    fw2 = "0" * (8 - len(fw2)) + fw2
                    fw = str(int(fw1[0:4], 16)) + '.' + str(int(fw1[4:8], 16)) + '.' + str(int(fw2[0:4], 16)) + '.' + str(int(fw2[4:8], 16))
                except:
                    fw = ""

        manufacturer = manufacturer.replace('\0', '')
        vendor_str = vendor_str.replace('\0', '')
        return manufacturer, vendor_str, fw

    def write_support_file(self, support_file):
            qt_properties = os.path.join(self.detail_dir, 'Quicktest_properties-fixed.txt')
            if os.path.isfile(qt_properties):
                support_file.write('\nQuicktest_properties-fixed\n')
                with open(os.path.join(self.detail_dir, 'Quicktest_properties-fixed.txt'), 'r') as infile:
                    properties = ""
                    for line in infile:
                        if line.startswith('  as UINT32:'):
                            continue
                        if line.startswith('  as string:'):
                            line = line[line.find('"'):]
                            properties = properties[:-1] + '\t' + line
                        else:
                            properties += line.replace(':', ';')
                    support_file.write(properties)

            qt_algorithms = os.path.join(self.detail_dir, 'Quicktest_algorithms.txt')
            if os.path.isfile(qt_algorithms):
                support_file.write('\nQuicktest_algorithms\n')
                with open(qt_algorithms, 'r') as infile:
                    for line in infile:
                        if line.startswith('TPMA_ALGORITHM'):
                            line = line[line.find('0x'):]
                            line = line[:line.find(' ')]
                            support_file.write(line + '\n')

            qt_commands = os.path.join(self.detail_dir, 'Quicktest_commands.txt')
            if os.path.isfile(qt_commands):
                support_file.write('\nQuicktest_commands\n')
                with open(qt_commands, 'r') as infile:
                    for line in infile:
                        if line.startswith('  commandIndex:'):
                            line = line[line.find('0x'):]
                            support_file.write(line)

            qt_ecc_curves = os.path.join(self.detail_dir, 'Quicktest_ecc-curves.txt')
            if os.path.isfile(qt_ecc_curves):
                support_file.write('\nQuicktest_ecc-curves\n')
                with open(os.path.join(self.detail_dir, 'Quicktest_ecc-curves.txt'), 'r') as infile:
                    for line in infile:
                        line = line[line.find('(') + 1:line.find(')')]
                        support_file.write(line + '\n')

    def write_perf_file(self, perf_file):
        perf_csvs = glob.glob(os.path.join(self.detail_dir, 'Perf_*.csv'))
        perf_csvs.sort()
        command = ''
        for filepath in perf_csvs:
            filename = os.path.basename(filepath)
            params_idx = filename.find(':')
            suffix_idx = filename.find('.csv')
            new_command = filename[5:suffix_idx if params_idx == -1 else params_idx]
            params = filename[params_idx+1:suffix_idx].split('_')
            if new_command != command:
                command = new_command
                perf_file.write('TPM2_' + command + '\n\n')

            if command == 'GetRandom':
                perf_file.write(f'Data length (bytes):;32\n')
            elif command in [ 'Sign', 'VerifySignature', 'RSA_Encrypt', 'RSA_Decrypt' ]:
                perf_file.write(f'Key parameters:;{params[0]} {params[1]};Scheme:;{params[2]}\n')
            elif command == 'EncryptDecrypt':
                perf_file.write(f'Algorithm:;{params[0]};Key length:;{params[1]};Mode:;{params[2]};Encrypt/decrypt?:;{params[3]};Data length (bytes):;256\n')
            elif command == 'HMAC':
                perf_file.write('Hash algorithm:;SHA-256;Data length (bytes):;256\n')
            elif command == 'Hash':
                perf_file.write(f'Hash algorithm:;{params[0]};Data length (bytes):;256\n')
            else:
                perf_file.write(f'Key parameters:;{" ".join(params)}\n')

            with open(filepath, 'r') as infile:
                avg_op, min_op, max_op, total, success, fail, error = self.compute_stats(infile)
                perf_file.write(f'operation stats (ms/op):;avg op:;{avg_op:.2f};min op:;{min_op:.2f};max op:;{max_op:.2f}\n')
                perf_file.write(f'operation info:;total iterations:;{total};successful:;{success};failed:;{fail};error:;{"None" if not error else error}\n\n')

    def compute_stats(self, infile, *, rsa2048=False):
        ignore = 5 if rsa2048 else 0
        success, fail, sum_op, min_op, max_op, avg_op = 0, 0, 0, 10000000000, 0, 0
        error = None
        for line in infile:
            if line.startswith('duration'):
                continue
            if ignore > 0:
                ignore -= 1
                continue
            t, rc = line.split(',')[:2]
            rc = rc.replace(' ', '')
            rc = rc.replace('\n', '')
            if rc == '0000':
                success += 1
            else:
                error = rc
                fail += 1
                continue
            t = float(t)
            sum_op += t
            if t > max_op: max_op = t
            if t < min_op: min_op = t
        total = success + fail
        if success != 0:
            avg_op = (sum_op / success)
        else:
            min_op = 0

        return avg_op * 1000, min_op * 1000, max_op * 1000, total, success, fail, error # sec -> ms

    def zip(self):
        self.tick()
        self.zip_path = self.outdir + '.zip'
        zipf = zipfile.ZipFile(self.zip_path, 'w', zipfile.ZIP_DEFLATED)
        for root, _, files in os.walk(self.outdir):
            for file in files:
                self.tick()
                file_path = os.path.join(root, file)
                zipf.write(file_path, file_path[len(self.outdir):])
                self.tick()
        self.tick()
        zipf.close()

    def generate_zip(self):
        self.create_result_files()
        self.zip()
        return self.zip_path

    def tick(self, alive=True):
        if self.watchdog_tick is not None:
            self.watchdog_tick(alive)


class AlgtestState(Enum):
    NOT_RUNNING = auto()
    RUNNING = auto()
    SUCCESS = auto()
    FAILED = auto()
    STOPPED = auto()


class TestType(Enum):
    PERFORMANCE = auto()
    KEYGEN = auto()
    NONCE = auto()
    RNG = auto()


class StoreType(Enum):
    STORE_USB = auto()
    UPLOAD = auto()
    CANCEL = auto()

class AlgtestTestRunner(Thread):
    def __init__(self, out_dir, watchdog_tick = None):
        super().__init__(name="AlgtestTestRunner")
        self.out_dir = out_dir
        self.detail_dir = os.path.join(self.out_dir, 'detail')
        self.cmd = ["tpm2_algtest", "-T", TCTI_SPEC, '--outdir=' + self.detail_dir, "-s"]

        self.percentage = 0
        self.text = []
        self.statuses = []
        self.status = ""
        self.state = AlgtestState.NOT_RUNNING
        self.watchdog_tick = watchdog_tick
        self.info_lock = Lock()
        self.info_changed = True

        self.tests_to_run = deque()
        self.algtest_proc = None
        self.shall_stop = False

        self.test_finished = False
        self.email = None
        self.result_collector = None

        self.uploader = ISUploader("tpm2-algtest-ui", DEPOSITORY_UCO)

    def run(self):
        self.set_state(AlgtestState.RUNNING)
        self.set_percentage(1)
        total_tests = len(self.tests_to_run)
        current_test = 1

        self.append_text("Collecting basic TPM info...")
        self.set_status("Collecting basic TPM info...")
        self.tick()

        code = self.run_quicktest()
        if code != 0:
            self.append_text("Cannot collect TPM 2.0 info. Your TPM may probably be disabled in BIOS or you do not have a TPM 2.0.")
            self.set_status("Cannot collect TPM 2.0 info.")
            self.set_state(AlgtestState.FAILED)
            self.zip_results()
            self.tick(False)
            return code

        result_collector = TestResultCollector(self.out_dir, self.get_mail(), self.text, self.watchdog_tick)
        manufacturer, vendor_str, fw = result_collector.get_tpm_id()
        self.append_text("TPM 2.0 detected")
        self.append_text(f'TPM manufacturer: "{manufacturer}"')
        self.append_text(f'TPM firmware version: "{fw}"')
        self.append_text(f'TPM vendor string: "{vendor_str}"')

        while self.tests_to_run and not self.get_shall_stop():
            test, duration = self.tests_to_run.popleft()
            os.makedirs(self.detail_dir, exist_ok=True)

            self.append_text(f"Running the {test.name.lower()} test... ({current_test}/{total_tests})")
            self.set_status(f"Running the {test.name.lower()} test... ({current_test}/{total_tests})")
            self.tick()
            if test == TestType.PERFORMANCE:
                self.algtest_proc = subprocess.Popen(self.cmd + ["perf", "-n", str(duration)], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
            elif test == TestType.KEYGEN:
                self.algtest_proc = subprocess.Popen(self.cmd + ["keygen", "-n", str(duration)], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
            elif test == TestType.NONCE:
                self.algtest_proc = subprocess.Popen(self.cmd + ["nonce", "-n", str(duration)], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
            elif test == TestType.RNG:
                self.algtest_proc = subprocess.Popen(self.cmd + ["rng", "-n", str(duration)], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)

            fd = self.algtest_proc.stdout.fileno()
            fl = fcntl.fcntl(fd, fcntl.F_GETFL)
            fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

            self.monitor_algtest(current_test, total_tests)

            if self.algtest_proc.poll() is None:
                if self.get_shall_stop():
                    self.algtest_proc.terminate()

                print("Waiting for the tpm2_algtest process to finish...")
                self.append_text("Waiting for the tpm2_algtest process to finish...")
                self.algtest_proc.wait()

            # read the rest of output, except the trailing newline
            self.append_text(self.algtest_proc.stdout.read().decode("ascii")[:-1])

            code = self.algtest_proc.returncode
            if code != 0:
                if not self.get_shall_stop():
                    print("The tpm2_algtest process failed. Please try to re-run the test.")
                    self.append_text("The tpm2_algtest process failed. Please try to re-run the test.")
                    self.set_status("The tpm2_algtest process failed.")
                    self.set_state(AlgtestState.FAILED)
                    self.tick(False)
                else:
                    self.set_status("Stop requested.")
                    self.set_state(AlgtestState.STOPPED)
                    self.tick(False)
                self.zip_results()
                self.tick(False)
                return code

            self.append_text(f"The {test.name.lower()} test finished")

            if test == TestType.KEYGEN and not self.get_shall_stop():
                self.append_text("Computing RSA private keys...")
                self.set_status("Computing RSA private keys...")
                self.tick()
                self.keygen_post()

            if test == TestType.NONCE and not self.get_shall_stop():
                self.append_text("Computing ECC nonces...")
                self.set_status("Computing ECC nonces...")
                self.tick()
                self.nonce_post()

            current_test += 1

        r = None
        if self.get_shall_stop():
            self.append_text("Stop requested.")
            self.set_status("Stop requested.")
            r = 1
            self.set_state(AlgtestState.STOPPED)
        else:
            r = 0
            self.set_state(AlgtestState.SUCCESS)
            self.append_text("All tests finished successfully.")
            self.set_status("All tests finished successfully.")

        self.zip_results()

        self.tick(False)
        return r

    def zip_results(self):
        self.append_text("Please wait, collecting results...")
        self.set_status("Please wait, collecting results...")
        self.tick()
        if self.result_collector is None:
            self.result_collector = TestResultCollector(self.out_dir, self.get_mail(), self.text, self.watchdog_tick)
        self.result_collector.generate_zip()
        self.append_text("Results collected.")
        self.set_status("Results collected.")

        self.set_percentage(100)
        with self.info_lock:
            self.test_finished = True

    def store_results(self, store_type):
        result_zip = self.out_dir + '.zip'
        zip_filename = os.path.basename(result_zip)

        if not os.path.isdir(RESULT_PATH):
            if os.system("mkdir -p " + RESULT_PATH + " && mount /dev/disk/by-label/ALGTEST_RES " + RESULT_PATH) == 0:
                self.append_text("Successfully mounted ALGTEST_RES partition")

        if os.path.isdir(RESULT_PATH):
            try:
                copyfile(result_zip, os.path.join(RESULT_PATH, zip_filename))
                self.append_text("Copied to USB. File name: " + zip_filename)
                with open(os.path.join(RESULT_PATH, "README_AND_HOW_TO_UPLOAD.txt"), "w") as readme_file:
                    readme_file.write(INFO_MESSAGE_PLAIN)
                os.sync()
            except:
                self.append_text("Failed to copy to USB.")
                self.set_status("Failed to copy to USB.")
        else:
            self.append_text("ALGTEST_RES partition is not mounted. Can not store on USB.")

        if store_type == StoreType.UPLOAD:
            self.append_text("Uploading results...")
            if self.uploader.upload(result_zip):
                self.append_text("Results uploaded successfully.")
                self.set_status("Results uploaded successfully.")
            else:
                self.append_text("Results upload failed.")
                self.set_status("Results upload failed.")

    def set_mail(self, email):
        with self.info_lock:
            self.email = email

    def get_mail(self):
        with self.info_lock:
            return self.email

    def is_finished(self):
        with self.info_lock:
            return self.test_finished

    def set_finished(self):
        with self.info_lock:
            self.test_finished = True

    def get_info_changed(self):
        with self.info_lock:
            if not self.info_changed:
                return False

            self.info_changed = False
            return True

    def monitor_algtest(self, current_test, total_tests):
        if self.algtest_proc is None:
            return

        while self.algtest_proc.poll() is None and not self.get_shall_stop():
            self.tick()
            line = self.algtest_proc.stdout.readline().decode("ascii")
            while line != "" and not self.get_shall_stop():
                if 2 < len(line) <= 5 and line[-2] == "%":
                    current_test_percentage = int(line[:-2]) / 100
                    absolute_percentage = ((current_test - 1) / total_tests) + (1/total_tests) * current_test_percentage
                    absolute_percentage = int(absolute_percentage * 100)
                    absolute_percentage = min(absolute_percentage + 1, 100)  # at this point test is started, so we make the progress at least 1 percent
                    self.set_percentage(absolute_percentage)
                else:
                    self.append_text(line[:-1])
                line = self.algtest_proc.stdout.readline().decode("ascii")

    def append_text(self, text):
        with self.info_lock:
            self.text.append(datetime.datetime.now().strftime("%H:%M:%S") + " " + text)
            self.info_changed = True

    def get_text(self, lines=400):
        with self.info_lock:
            return "\n".join(self.text[-lines:] if lines else self.text)

    def set_state(self, state):
        with self.info_lock:
            self.state = state
            self.info_changed = True

    def get_state(self):
        with self.info_lock:
            return self.state

    def set_status(self, status):
        with self.info_lock:
            self.status = status
            self.statuses.append("<b>" + datetime.datetime.now().strftime("%H:%M:%S") + "</b>: " + status)
            self.info_changed = True

    def get_statuses(self):
        with self.info_lock:
            return "<br>".join(self.statuses)

    def get_status(self):
        with self.info_lock:
            return self.status

    def tick(self, alive=True):
        if self.watchdog_tick is not None:
            self.watchdog_tick(alive)

    def set_percentage(self, value):
        with self.info_lock:
            self.percentage = value
            self.info_changed = True

    def get_percentage(self):
        with self.info_lock:
            return self.percentage

    def stop(self):
        with self.info_lock:
            self.shall_stop = True

    def get_shall_stop(self):
        with self.info_lock:
            return self.shall_stop

    def keygen_post(self):
        for filename in glob.glob(os.path.join(self.detail_dir, 'Keygen:RSA_*.csv')):
            self.compute_rsa_privates(filename)

    def nonce_post(self):
        for filename in glob.glob(os.path.join(self.detail_dir, 'Nonce:ECC_*.csv')):
            self.compute_nonce(filename)

    def run_quicktest(self):
        os.makedirs(self.detail_dir, exist_ok=True)

        result = subprocess.run("sudo -n dmidecode -s bios-version", stderr=subprocess.STDOUT, stdout=subprocess.PIPE, shell=True)
        with open(os.path.join(self.detail_dir, 'dmidecode_bios_version.txt'), 'w') as outfile:
            outfile.write(result.stdout.decode("ascii"))

        result = subprocess.run("sudo -n dmidecode | grep -A3 '^System Information'", stderr=subprocess.STDOUT, stdout=subprocess.PIPE, shell=True)
        with open(os.path.join(self.detail_dir, 'dmidecode_system_info.txt'), 'w') as outfile:
            outfile.write(result.stdout.decode("ascii"))

        result = subprocess.run(['tpm2_pcrread', '-T', TCTI_SPEC], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
        with open(os.path.join(self.detail_dir, 'Quicktest_pcrread.txt'), 'w') as outfile:
            outfile.write(result.stdout.decode("ascii"))

        run_command = ['tpm2_getcap', '-T', TCTI_SPEC]

        getcap_proc = subprocess.Popen(["tpm2_getcap", "-v"], stdout=subprocess.PIPE)
        line = getcap_proc.stdout.readline().decode("ascii")
        version_begin = line.find('version="') + len('version="')
        version_end = line.find('"', version_begin)
        version = line[version_begin:version_end].split(".")
        version = list(map(int, version))

        self.tick()

        # newer versions take category directly as an argument, older need -c
        if version < [4, 0, 0]:
            run_command.append("-c")

        result_code = 0
        categories = ['algorithms', 'commands', 'properties-fixed', 'properties-variable', 'ecc-curves', 'handles-persistent']
        for category in categories:
            self.tick()
            result = subprocess.run(run_command + [category], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
            # read the output, except the trailing newline
            self.append_text(result.stdout.decode("ascii")[:-1])
            self.tick()
            with open(os.path.join(self.detail_dir, f'Quicktest_{category}.txt'), 'w') as outfile:
                outfile.write(result.stdout.decode("ascii"))
            if result.returncode != 0:
                self.append_text("Command '" + " ".join(run_command + [category]) + "' failed with return code " + str(result.returncode))
                result_code = result.returncode
        self.tick()
        return result_code

    def schedule_test(self, test):
        self.tests_to_run.append(test)

    def terminate(self):
        self.stop()
        if self.is_alive():
            self.join()

        if self.algtest_proc is not None and self.algtest_proc.poll() is None:
            self.algtest_proc.terminate()

    def compute_nonce(self, filename):
        CURVE_ORDER = {
            "P256": 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551,
            "P384": 0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973,
            "BN256": 0xfffffffffffcf0cd46e5f25eee71a49e0cdc65fb1299921af62d536cd10b500d
        }

        def extract_ecdsa_nonce(n, r, s, x, e):
            # https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
            return (pow(s, -1, n) * (e + (r * x) % n) % n) % n

        def extract_ecschnorr_nonce(n, r, s, x, e):
            # https://trustedcomputinggroup.org/wp-content/uploads/TPM2.0-Library-Spec-v1.16-Errata_v1.5_09212016.pdf
            return (s - (r * x) % n) % n

        def extract_sm2_nonce(n, r, s, x, e):
            # https://crypto.stackexchange.com/questions/9918/reasons-for-chinese-sm2-digital-signature-algorithm
            return (s + (s * x) % n + (r * x) % n) % n

        def compute_row(row):
            try:
                digest = int(row['digest'], 16)
                curve = { 0x3: "P256", 0x4: "P384", 0x10: "BN256" }[int(row['curve'], 16)]
                algorithm = { 0x18: "ECDSA", 0x1b: "SM2", 0x1c: "ECSCHNORR" }[int(row['algorithm'], 16)]
                signature_r = int(row['signature_r'], 16)
                signature_s = int(row['signature_s'], 16)
                private_key = int(row['private_key'], 16)

                row['nonce'] = hex({
                    "ECDSA": extract_ecdsa_nonce,
                    "ECSCHNORR": extract_ecschnorr_nonce,
                    "SM2": extract_sm2_nonce
                }[algorithm](CURVE_ORDER[curve], signature_r, signature_s, private_key, digest))[2:]

            except Exception:
                print(f"Cannot compute row {row['id']}")
                return

        rows = []
        with open(filename) as infile:
            reader = csv.DictReader(infile, delimiter=',')
            for row in reader:
                rows.append(row)

        for row in rows:
            compute_row(row)

        with open(filename, 'w') as outfile:
            writer = csv.DictWriter(
                    outfile, delimiter=',', fieldnames=list(rows[0].keys()))
            writer.writeheader()
            for row in rows:
                writer.writerow(row)

    def compute_rsa_privates(self, filename):
        def extended_euclidean(a, b):
            x0, x1, y0, y1 = 0, 1, 1, 0
            while a != 0:
                q, b, a = b // a, a, b % a
                y0, y1 = y1, y0 - q * y1
                x0, x1 = x1, x0 - q * x1
            return b, x0, y0

        def mod_exp(base, exp, n):
            res = 1
            base %= n
            while exp > 0:
                if exp % 2 == 1:
                    res *= base
                    res %= n
                exp //= 2
                base *= base
                base %= n
            return res

        def compute_row(row):
            try:
                n = int(row['n'], 16)
                e = int(row['e'], 16)
                p = int(row['p'], 16)
            except Exception:
                print(f"Cannot compute row {row['id']}")
                self.append_text(f"Cannot compute row {row['id']}")
                return
            q = n // p
            totient = (p - 1) * (q - 1)
            _, d, _ = extended_euclidean(e, totient)
            d %= totient

            message = 12345678901234567890
            assert mod_exp(mod_exp(message, e, n), d, n) == message, \
                f"something went wrong (row {row['id']})"

            row['q'] = '%X' % q
            row['d'] = '%X' % d

        rows = []
        with open(filename) as infile:
            reader = csv.DictReader(infile, delimiter=';')
            for row in reader:
                rows.append(row)

        for row in rows:
            compute_row(row)

        with open(filename, 'w') as outfile:
            writer = csv.DictWriter(
                    outfile, delimiter=';', fieldnames=list(rows[0].keys()))
            writer.writeheader()
            for row in rows:
                writer.writerow(row)


class TPM2AlgtestUI:
    def __init__(self):
        self.reset_ui_members()

        self.simple_mode = True
        self.result_stored = False

        #  TODO: init to None
        self.out_dir = os.path.join(mkdtemp(), "tpm2-algtest", "algtest_result_" + str(uuid4()))
        os.makedirs(self.out_dir, exist_ok=True)
        self.algtest_runner = AlgtestTestRunner(self.out_dir, lambda alive: self.busy_indicator.setAlive(alive))

    def reset_ui_members(self):
        self.dialog = None
        self.vbox = None
        self.group = None
        self.type_box = None
        self.keygen_button = None
        self.perf_button = None
        self.rng_button = None
        self.nonce_button = None
        self.progress_bar = None
        self.busy_indicator = None
        self.text = None
        self.bottom_buttons = None
        self.run_button = None
        self.stop_button = None
        self.store_button = None
        self.info_button = None
        self.advanced_button = None
        self.shutdown_checkbox = None
        # self.email_field = None
        self.exit_button = None

        self.popup_info = None
        self.popup_info_hide_button = None

        self.popup = None
        self.yesNoButtons = None
        self.popup_upload = None
        self.popup_usb = None
        self.popup_cancel = None

    def construct_advanced_ui(self):
        self.simple_mode = False

        YUI.application().setApplicationIcon("/usr/share/icons/hicolor/256x256/apps/tpm2-algtest.png")
        YUI.application().setProductName("TPM2 algorithms test " + VERSION)
        YUI.application().setApplicationTitle("TPM2 algorithms test " + VERSION)
        self.dialog = YUI.widgetFactory().createMainDialog()

        self.vbox = YUI.widgetFactory().createVBox(self.dialog)
        self.hbox = YUI.widgetFactory().createHBox(self.vbox)
        YUI.widgetFactory().createLabel(self.hbox, "Select the test type")

        self.type_box = YUI.widgetFactory().createHBox(self.hbox)

        self.keygen_button = YUI.widgetFactory().createCheckBox(self.type_box, "&keygen")
        self.keygen_button.setValue(True)
        self.perf_button = YUI.widgetFactory().createCheckBox(self.type_box, "&performance")
        self.perf_button.setValue(True)
        self.rng_button = YUI.widgetFactory().createCheckBox(self.type_box, "&RNG")
        self.rng_button.setValue(True)
        self.nonce_button = YUI.widgetFactory().createCheckBox(self.type_box, "&nonce")
        self.nonce_button.setValue(True)

        self.hbox2 = YUI.widgetFactory().createHBox(self.vbox)
        YUI.widgetFactory().createLabel(self.hbox2, "Select number of test repetitions: ")

        self.group = YUI.widgetFactory().createRadioButtonGroup(self.hbox2)
        self.duration_box = YUI.widgetFactory().createHBox(self.group)

        self.duration_100_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&100 (Default)")
        self.duration_100_button.setValue(True)
        self.group.addRadioButton(self.duration_100_button)

        self.duration_200_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&200")
        self.group.addRadioButton(self.duration_200_button)

        self.duration_300_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&300")
        self.group.addRadioButton(self.duration_300_button)

        self.duration_400_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&400")
        self.group.addRadioButton(self.duration_400_button)

        self.duration_500_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&500")
        self.group.addRadioButton(self.duration_500_button)

        self.duration_1000_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&1000")
        self.group.addRadioButton(self.duration_1000_button)

        self.duration_1500_button = YUI.widgetFactory().createRadioButton(self.duration_box, "&1500")
        self.group.addRadioButton(self.duration_1500_button)

        # YUI.widgetFactory().createLabel(self.vbox,
        #   "The collected information does not contain any of your personal information.\n" \
        #   "It will be sent to Masaryk University information system and it will be used\n" \
        #   "for research purposes regarding the performance and the security of the keys\n"
        #   "generated by your TPM. The test might take 1-4 hours.\n\n" \
        #   "We may need to contact you in the future if we need more info.\n" \
        #   "The email address won't be shared with anybody and you will not receive any advertisement.\n")

        # self.email_field = YUI.widgetFactory().createInputField(self.vbox, "Your email (optional): ")

        self.running_label = YUI.widgetFactory().createLabel(self.vbox, "Test is not running.")

        self.busy_indicator = YUI.widgetFactory().createBusyIndicator(self.vbox, "Test status", 25000)
        self.busy_indicator.setAlive(False)

        self.progress_bar = YUI.widgetFactory().createProgressBar(self.vbox, "Test progress", 100)
        self.progress_bar.setValue(0)

        self.text = YUI.widgetFactory().createRichText(self.vbox, "", True)
        self.text.setText("Select the test type and press RUN to start.")
        self.text.setAutoScrollDown(True)

        self.bottom_buttons = YUI.widgetFactory().createHBox(self.vbox)
        start_highlight_box = YUI.widgetFactory().createHBox(self.bottom_buttons)
        self.run_button = YUI.widgetFactory().createPushButton(start_highlight_box, "&Start")
        self.dialog.highlight(start_highlight_box)
        self.dialog.setDefaultButton(self.run_button)
        self.info_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Info")
        self.stop_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Stop")

        if  YUI.application().isTextMode():
            self.exit_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Exit")
        self.shutdown_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Shutdown PC")
        self.simple_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Simple mode")

        self.dialog.open()
        self.dialog.activate()

    def construct_simple_ui(self):
        self.simple_mode = True

        YUI.application().setApplicationIcon("/usr/share/icons/hicolor/256x256/apps/tpm2-algtest.png")
        YUI.application().setProductName("TPM2 algorithms test " + VERSION)
        YUI.application().setApplicationTitle("TPM2 algorithms test " + VERSION)
        self.dialog = YUI.widgetFactory().createMainDialog()

        self.vbox = YUI.widgetFactory().createVBox(self.dialog)

        # self.email_field = YUI.widgetFactory().createInputField(self.vbox, "Your email (optional): ")

        self.running_label = YUI.widgetFactory().createLabel(self.vbox, "Test is not running.")

        self.busy_indicator = YUI.widgetFactory().createBusyIndicator(self.vbox, "Test status", 25000)
        self.busy_indicator.setAlive(False)

        self.progress_bar = YUI.widgetFactory().createProgressBar(self.vbox, "Test progress", 100)
        self.progress_bar.setValue(0)

        self.shutdown_checkbox = YUI.widgetFactory().createCheckBox(self.vbox, "Shutdown when test finishes successfully")

        self.text = YUI.widgetFactory().createRichText(self.vbox, "")
        self.text.setAutoScrollDown(True)

        self.bottom_buttons = YUI.widgetFactory().createHBox(self.vbox)
        start_highlight_box = YUI.widgetFactory().createHBox(self.bottom_buttons)
        self.run_button = YUI.widgetFactory().createPushButton(start_highlight_box, "&Start")
        self.dialog.highlight(start_highlight_box)
        self.dialog.setDefaultButton(self.run_button)
        self.info_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Info")
        self.stop_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Stop")

        if  YUI.application().isTextMode():
            self.exit_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Exit")
        self.shutdown_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Shutdown PC")
        self.advanced_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Advanced mode")

        self.dialog.open()
        self.dialog.activate()

    def popup_ask_upload(self):
        self.popup = YUI.widgetFactory().createPopupDialog()

        popup_vbox = YUI.widgetFactory().createVBox(self.popup)
        YUI.widgetFactory().createLabel(popup_vbox, "Do you want to upload the anonymised "\
            "results or just store on the USB?\nResults will be available after plugging "\
            "the live USB on ALGTEST_RESULTS volume.\nPlease, connect to a network before choosing to upload.\n")
        self.yesNoButtons = YUI.widgetFactory().createHBox(popup_vbox)

        self.yesNoButtons = YUI.widgetFactory().createHBox(popup_vbox)
        self.popup_usb = YUI.widgetFactory().createPushButton(self.yesNoButtons, "&Just store on USB")
        self.popup_upload = YUI.widgetFactory().createPushButton(self.yesNoButtons, "&Upload and store")
        self.popup_cancel = YUI.widgetFactory().createPushButton(self.yesNoButtons, "&Cancel")
        self.popup.setDefaultButton(self.popup_usb)

        self.popup.open()
        self.popup.activate()

    def popup_info_show(self):
        self.popup_info = YUI.widgetFactory().createPopupDialog()
        if not YUI.application().isTextMode():
            self.popup_info.setSize(550, 600)

        popup_vbox = YUI.widgetFactory().createVBox(self.popup_info)

        # YUI.widgetFactory().createLabel(popup_vbox, "\n\n")
        # YUI.widgetFactory().createLabel(popup_vbox, INFO_MESSAGE)

        text_vbox = YUI.widgetFactory().createVBox(popup_vbox)
        text = YUI.widgetFactory().createRichText(text_vbox, INFO_MESSAGE)
        text.setShrinkable(False)

        self.popup_info_hide_button = YUI.widgetFactory().createPushButton(popup_vbox, "&Continue")

        self.popup_info.open()
        self.popup_info.activate()


    def main_ui_loop(self):
        self.popup_info_show()
        while self.dialog is not None and self.dialog.isOpen():
            ev = self.dialog.topmostDialog().waitForEvent(100)

            if self.algtest_runner.is_finished() and self.dialog.topmostDialog() != self.popup and not self.result_stored:
                if self.simple_mode:
                    self.algtest_runner.store_results(StoreType.STORE_USB)
                    self.result_stored = True
                    if self.shutdown_checkbox.isChecked() and self.algtest_runner.get_state() == AlgtestState.SUCCESS:
                        os.system("shutdown -h now")
                else:
                    if self.store_button is None:
                        self.popup_ask_upload()
                        self.store_button = YUI.widgetFactory().createPushButton(self.bottom_buttons, "&Store or upload results")

            if ev.eventType() == YEvent.CancelEvent or (self.exit_button is not None and ev.widget() == self.exit_button):
                if self.popup is not None:
                    self.popup.destroy()
                    self.popup = None
                    continue

                if self.popup_info is not None:
                    self.popup_info.destroy()
                    self.popup_info = None
                    continue

                if self.algtest_runner.is_alive():
                    self.algtest_runner.terminate()


                self.dialog.destroy()
                self.dialog = None
            elif ev.eventType() == YEvent.WidgetEvent:
                if ev.widget() == self.stop_button:
                    self.algtest_runner.terminate()
                elif ev.widget() == self.run_button:
                    if self.store_button is not None:
                        self.store_button.parent().removeChild(self.store_button)
                        self.store_button = None
                        self.result_stored = False

                    if self.algtest_runner.is_alive():
                        self.algtest_runner.terminate()

                    self.out_dir = os.path.join(mkdtemp(), "tpm2-algtest", "algtest_result_" + str(uuid4()))
                    os.makedirs(self.out_dir, exist_ok=True)
                    self.algtest_runner = AlgtestTestRunner(self.out_dir, lambda alive: self.busy_indicator.setAlive(alive))
                    # self.algtest_runner.set_mail(self.email_field.value())

                    if self.simple_mode:
                            self.algtest_runner.schedule_test((TestType.KEYGEN, 100))
                            self.algtest_runner.schedule_test((TestType.PERFORMANCE, 100))
                            self.algtest_runner.schedule_test((TestType.NONCE, 100))
                            self.algtest_runner.schedule_test((TestType.RNG, 100))
                    else:
                        duration = 100

                        if self.duration_200_button.value():
                            duration = 200
                        elif self.duration_300_button.value():
                            duration = 300
                        elif self.duration_400_button.value():
                            duration = 400
                        elif self.duration_500_button.value():
                            duration = 500
                        elif self.duration_1000_button.value():
                            duration = 1000
                        elif self.duration_1500_button.value():
                            duration = 1500

                        if self.keygen_button.isChecked():
                            self.algtest_runner.schedule_test((TestType.KEYGEN, duration))

                        if self.perf_button.isChecked():
                            self.algtest_runner.schedule_test((TestType.PERFORMANCE, duration))

                        if self.nonce_button.isChecked():
                            self.algtest_runner.schedule_test((TestType.NONCE, duration))

                        if self.rng_button.isChecked():
                            self.algtest_runner.schedule_test((TestType.RNG, duration))

                    self.algtest_runner.start()
                elif ev.widget() == self.popup_cancel:
                    self.popup.destroy()
                    self.popup = None
                elif ev.widget() == self.popup_usb:
                    self.algtest_runner.store_results(StoreType.STORE_USB)
                    self.popup.destroy()
                    self.popup = None
                elif ev.widget() == self.popup_upload:
                    self.algtest_runner.store_results(StoreType.UPLOAD)
                    self.popup.destroy()
                    self.popup = None
                elif ev.widget() == self.store_button:
                    self.popup_ask_upload()
                elif ev.widget() == self.shutdown_button:
                    os.system("shutdown -h now")
                elif ev.widget() == self.popup_info_hide_button:
                    self.popup_info.destroy()
                    self.popup_info = None
                elif ev.widget() == self.info_button:
                    self.popup_info_show()
                elif ev.widget() == self.advanced_button:
                    self.dialog.destroy()
                    self.reset_ui_members()
                    self.construct_advanced_ui()
                elif ev.widget() == self.simple_button:
                    self.dialog.destroy()
                    self.reset_ui_members()
                    self.construct_simple_ui()

            elif ev.eventType() == YEvent.TimeoutEvent:
                if self.algtest_runner.get_info_changed():
                    self.progress_bar.setValue(self.algtest_runner.get_percentage())
                    if self.simple_mode:
                        self.text.setText(self.algtest_runner.get_statuses())
                    else:
                        self.text.setText(self.algtest_runner.get_text())
                    self.busy_indicator.setLabel(self.algtest_runner.get_status())

                    if self.algtest_runner.get_state() == AlgtestState.NOT_RUNNING:
                        self.running_label.setText("Test is not yet running")
                        self.running_label.setUseBoldFont(False)
                    elif self.algtest_runner.get_state() == AlgtestState.RUNNING:
                        self.running_label.setText("Test is running, please do not power off your computer and plug it into AC")
                        self.running_label.setUseBoldFont(True)
                    elif self.algtest_runner.get_state() == AlgtestState.SUCCESS:
                        if self.result_stored:
                            self.running_label.setText("Test finished successfully and the result was stored. You can exit now.")
                        else:
                            self.running_label.setText("Testing completed, storing the result")
                        self.running_label.setUseBoldFont(True)
                    elif self.algtest_runner.get_state() == AlgtestState.FAILED:
                        if self.result_stored:
                            self.running_label.setText("Test failed and the partial result was stored. Try to re-run the test.")
                        else:
                            self.running_label.setText("Test failed, storing the partial result")
                        self.running_label.setUseBoldFont(True)


if __name__ == "__main__":
    ui = TPM2AlgtestUI()
    ui.construct_simple_ui()
    ui.main_ui_loop()
